i = len(arr)-1
    while i >= 0:
        if m - arr[i] in arr and arr.index(m - arr[i]) != i:
            return [arr.index(m - arr[i]) + 1, i + 1]
        i -= 1
        
         
index={}
    n=len(arr)
    for i in range(n):
        index[arr[i]]=i
    current=0
    for i in range(n,0,-1):
        if(arr[current]!=i):
            temp=arr[current]
            arr[current],arr[index[i]]=arr[index[i]],arr[current]
            index[i],index[temp]=index[temp],index[i]
            k-=1
            if(k==0):
                break
        current+=1
    return arr
 
return max([i^j for i in range(l,r+1) for j in range(i,r+1)])


partition list
class Solution {
    public ListNode partition(ListNode head, int x) 
    {
        ListNode smallerNodes = new ListNode(-1);
        ListNode greaterNodes = new ListNode(-1);

        ListNode p = smallerNodes, q = greaterNodes;

        while (head != null)
        {
            if (head.val >= x)
            {
                q.next = head;
                q = q.next;
            }
            else
            {
                p.next = head;
                p = p.next;
            }
            head = head.next;
        }
        p.next = greaterNodes.next;
        q.next = null;

        return smallerNodes.next;

        
    }
}




void addend(){
	struct node*temp;
	struct node*temp1;
	int n;
	temp=(struct node*)malloc(sizeof(struct node));
	printf("enter the no");
	scanf("%d",&n);
	temp->data=n;
	temp->link=NULL;
	if(p==NULL)
	{
		p=temp;	
	}
	else{
		temp1=p;
		while(temp1!=NULL){
			temp1=temp1->link;
			
		}
		temp1->link=temp;
	}
}














